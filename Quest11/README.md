# Quest 11. RDB의 기초와 ORM

## Introduction

- 이번 퀘스트에서는 데이터베이스를 다루는 방법에 대해 알아보겠습니다.

## Topics

- RDBMS
- MySQL
- ORM
- Hash
  - scrypt

## Resources

- [MySQL 101 – The basics](https://www.globo.tech/learning-center/mysql-101-basics/)
- [Sequelize](https://sequelize.org/)
- [안전한 패스워드 저장](https://d2.naver.com/helloworld/318732)

## Checklist

- RDBMS 테이블의 정규화는 무엇인가요?

  > - 정규화를 적절히 하지 않은 DB 또는 Relation(Table)에 데이터가 중복되고 이 Table에 어떠한 작업을 할 때 비합리적인 문제들이 발생하는 현상을 막기 위해 RDBMS(Relational DataBase Management System)를 설계할 때, 중복을 최소화하면서 데이터 구조를 짬.

- MySQL 외의 RDB에는 어떤 것들이 있나요?

       오라클 RDB
       윈도우OS 기반의 MS SQL
       IBM의 DB2
       Maria DB
       Derby
       SQLite

- Relational Database 외에 다른 DB에는 어떤 것들이 있을까요?

      파일 시스템
      계층형(Hierachical) DB 관리 시스템 (HDBMS)
      네트워크 DB 관리 시스템 (NDBMS)
      객체지향(Object Oriented) DB 관리 시스템 (ODBMS)

- RDBMS에서 테이블의 인덱싱은 무엇인가요? 인덱싱을 하면 어떤 점이 다르며, 어떤 식으로 동작하나요?

> - 인덱스 : 주로 검색(SELECT) 쿼리의 수행 속도를 높이기 위해 데이터베이스의 데이터 위치를 색인하여 기억하고 있는 기술로 테이블 단위로 생성하며 오라클의 경우 PK, FK 컬럼에는 자동으로 인덱스(색인)이 생성되고 옵티마이저의 판단에 따라 사용. 책으로 생각하면 목차가 있어 어느 페이지에 어떤 내용이 있는지 확인할 수 있다면 곧바로 찾는 내용이 있는 페이지로 갈 수 있는 장점과 비슷.

      INSERT: 새로운 데이터에 대한 인덱스를 추가함
      DELETE: 삭제하는 데이터의 "인덱스를 사용하지 않는다는 작업"을 진행함
      UPDATE: DELETE 처리하고, 인덱스를 추가함

- ORM을 사용하는 것은 사용하지 않는 것에 비해 어떤 장단점을 가지고 있나요?

  > - ORM(Object Relational Mapping) : DB와 객체 지향 프로그래밍 언어 간의 호환되지 않는 데이터를 변환, 맵핑(연결)하는 프로그래밍 기법. 이는 객체(클래스)와 관계(관계형 데이터베이스)와의 설정을 의미하고 객체 지향 프로그래밍은 클래스를 사용하고 관계형 데이터베이스는 테이블을 사용. 여기서 객체 모델과 관계형 모델 간의 불일치가 존재하는데 이를 객체 간의 관계를 바탕으로 SQL을 자동생성하여 불일치를 해결 해주는 것이 ORM.

      장점
      1. 별도의 SQL문을 사용하지 않아도 객체 지향 프로그래밍 언어로 구현이 가능하며 이는 곧 생산성 증가로 이어짐. 대량의 SQL Query를 쓰지 않고도 객체간의 관계를 풀어낼 수 있기 때문에 개발자가 좀 더 직관적으로 객체간의 관계를 파악 가능.
      2. 재사용 및 유지보수가 편리. 매핑하게 되면 정보가 명확해지기 때문에 ERD를 보는 것에 대한 의존도를 낮출 수 있음. ORM은 독립적으로 작성이 되어 있고 해당 객체들은 재사용이 가능.
      3. DBMS에 대한 종속성이 감소. 대부분의 ORM 프레임워크들은 DB에 종속적이지 않음. 그러므로 개발자들은 객체에 집중함으로써 DBMS를 교체하는 극단적인 작업에도 비교적 적은 리스크와 시간이 소요. (여기서 종속적이라는 것은 프로그램 구조가 데이터 구조에 영향을 받는 것을 의미)
      4. DB의 마이그레이션을 쉽게 할 수 있음.

      단점
      1. 직접 SQL문을 작성하는 것보다 상대적으로 복잡할 수가 있고 프로젝트의 복잡성이 높아질 경우 난이도가 그 만큼 상승. 모든 것을 ORM을 통해서만 구현하는 것은 힘듦. 잘못 구현된 경우에 속도 저하 및 심각할 경우 일관성이 무너지는 문제점이 생길 가능성이 있음.
      2. 기존의 기업들은 ORM을 고려하지 않은 DB를 사용하고 있어 ORM에 적합하게 변환하려면 많은 시간과 노력이 필요.
      3. DB와 바로 연결하는 것보다 초기설정이 더 많아지거나 복잡해 질 수 있음.
      4. DB와 ORM 프레임워크, 내부코드에 대한 충분한 이해가 없는 경우 문제 해결이 힘듦.
      5. DB에 직접 Query문을 보내는 것이 아니기 때문에 성능저하가 발생.

- 자바스크립트 생태계의 ORM에는 어떤 것들이 있나요?

> - Node.js 모듈중에 ‘Sequelize’라는 ORM 라이브러리가 있음.

- 모델간의 1:1, 1:N, N:M 관계는 각각 무엇이고 어떨 때 사용하나요?

      1:1 = 하나의 레코드가 다른 테이블의 레코드 한 개와 연결된 경우
      1:N = 하나의 레코드가 서로 다른 여러 개의 레코드와 연결된 경우
      N:M = 여러 개의 레코드가 다른 테이블의 여러 개의 레코드와 관계가 있는 경우

- DB에 사용자의 암호를 평문으로 저장하지 않고도 사용자의 암호를 인증하는 것이 가능한 이유는 무엇일까요?

  > - DB 를 가장하여 임의적으로 만든 클래스. 데이터는 UserData 라는 ArrayList 객체에 저장할 것이고, 유저의 아이디와 해싱된 패스워드(다이제스트), 유저 고유의 솔트를 저장하는 클래스. 즉, 여러분이 입력한 패스워드를 평문으로 저장하는 것이 아닌, 해싱 된 패스워드를 저장하기 때문에 개발자가 악의적으로 데이터를 뽑아서 팔아 넘기려 하더라도 원래의 비밀번호는 알기 힘듦.

- 해시 함수에는 어떤 것이 있나요?

      MD5
      SHA
      HAS
      RIPEMD(RMD)

- 사용자의 암호를 해싱하여 저장할 때 어떤 식으로 저장하는 것이 보안에 좋을까요?

  > - 항상 같은 결과값이 나온다는 특성을 이용해 해시 함수를 거치기 이전의 값을 알아낼 수 있도록 기록해놓은 표인 레인보우 테이블이 존재. 레인보우 테이블에 기록된 비밀번호의 경우에는 유출이 되었을 때 해싱을 했더라도 해싱 이전의 값을 알아낼 수 있으므로 보안상 위협이 될 수 있음.
  > - 이 때 활용할 수 있는 것이 솔트(Salt)입. 말 그대로 소금을 치듯 해싱 이전 값에 임의의 값을 더해 데이터가 유출 되더라도 해싱 이전의 값을 알아내기 더욱 어렵게 만드는 방법.
  > - 솔트는 유저와 패스워드별로 유일한 값을 가져야 하며, 절대 재사용 되어서는 안됨. 또한 사용자 계정을 생성할 때와 비밀번호를 변경할 때마다 새로운 솔트를 사용해야 하며, 데이터 베이스의 유저 테이블에 함께 저장되어야 함.

## Quest

- 이번에는 메모장을 파일이 아닌 DB기반으로 만들어 보고자 합니다.
  - 적절한 테이블을 설계해 보세요.
  - Sequelize를 이용하여 데이터의 모델을 만들고 어플리케이션에 적용해 보세요.
  - 사용자의 비밀번호는 해싱을 통해 저장되어야 합니다.

## Advanced

- Object–relational impedance mismatch란 어떤 개념인가요?
- Foreign Key란 무엇인가요? 이것을 사용할 때의 장점과 단점은 무엇일까요?
- 이전에 쓰이던 해시함수들에는 어떤 것이 있을까요? 패스워드 해싱의 추세의 역사는 어떻게 이어져왔나요?
